// src/generated/cluster/HDBSCAN.ts
import crypto from "node:crypto";
var HDBSCAN = class {
  constructor(opts) {
    this._isInitialized = false;
    this._isDisposed = false;
    this.id = `HDBSCAN${crypto.randomUUID().split("-")[0]}`;
    this.opts = opts || {};
  }
  get py() {
    return this._py;
  }
  set py(pythonBridge) {
    this._py = pythonBridge;
  }
  /**
      Initializes the underlying Python resources.
  
      This instance is not usable until the `Promise` returned by `init()` resolves.
     */
  async init(py) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (this._isInitialized) {
      return;
    }
    if (!py) {
      throw new Error("HDBSCAN.init requires a PythonBridge instance");
    }
    this._py = py;
    await this._py.ex`
import numpy as np
from sklearn.cluster import HDBSCAN
try: bridgeHDBSCAN
except NameError: bridgeHDBSCAN = {}
`;
    await this._py.ex`ctor_HDBSCAN = {'min_cluster_size': ${this.opts["min_cluster_size"] ?? void 0}, 'min_samples': ${this.opts["min_samples"] ?? void 0}, 'cluster_selection_epsilon': ${this.opts["cluster_selection_epsilon"] ?? void 0}, 'max_cluster_size': ${this.opts["max_cluster_size"] ?? void 0}, 'metric': ${this.opts["metric"] ?? void 0}, 'metric_params': ${this.opts["metric_params"] ?? void 0}, 'alpha': ${this.opts["alpha"] ?? void 0}, 'algorithm': ${this.opts["algorithm"] ?? void 0}, 'leaf_size': ${this.opts["leaf_size"] ?? void 0}, 'n_jobs': ${this.opts["n_jobs"] ?? void 0}, 'cluster_selection_method': ${this.opts["cluster_selection_method"] ?? void 0}, 'allow_single_cluster': ${this.opts["allow_single_cluster"] ?? void 0}, 'store_centers': ${this.opts["store_centers"] ?? void 0}, 'copy': ${this.opts["copy"] ?? void 0}}

ctor_HDBSCAN = {k: v for k, v in ctor_HDBSCAN.items() if v is not None}`;
    await this._py.ex`bridgeHDBSCAN[${this.id}] = HDBSCAN(**ctor_HDBSCAN)`;
    this._isInitialized = true;
  }
  /**
      Disposes of the underlying Python resources.
  
      Once `dispose()` is called, the instance is no longer usable.
     */
  async dispose() {
    if (this._isDisposed) {
      return;
    }
    if (!this._isInitialized) {
      return;
    }
    await this._py.ex`del bridgeHDBSCAN[${this.id}]`;
    this._isDisposed = true;
  }
  /**
      Return clustering given by DBSCAN without border points.
  
      Return clustering that would be equivalent to running DBSCAN\* for a particular cut\_distance (or epsilon) DBSCAN\* can be thought of as DBSCAN without the border points. As such these results may differ slightly from `cluster.DBSCAN` due to the difference in implementation over the non-core points.
  
      This can also be thought of as a flat clustering derived from constant height cut through the single linkage tree.
  
      This represents the result of selecting a cut value for robust single linkage clustering. The `min\_cluster\_size` allows the flat clustering to declare noise points (and cluster smaller than `min\_cluster\_size`).
     */
  async dbscan_clustering(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before dbscan_clustering()");
    }
    await this._py.ex`pms_HDBSCAN_dbscan_clustering = {'cut_distance': ${opts["cut_distance"] ?? void 0}, 'min_cluster_size': ${opts["min_cluster_size"] ?? void 0}}

pms_HDBSCAN_dbscan_clustering = {k: v for k, v in pms_HDBSCAN_dbscan_clustering.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_dbscan_clustering = bridgeHDBSCAN[${this.id}].dbscan_clustering(**pms_HDBSCAN_dbscan_clustering)`;
    return this._py`res_HDBSCAN_dbscan_clustering.tolist() if hasattr(res_HDBSCAN_dbscan_clustering, 'tolist') else res_HDBSCAN_dbscan_clustering`;
  }
  /**
    Find clusters based on hierarchical density-based clustering.
   */
  async fit(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit()");
    }
    await this._py.ex`pms_HDBSCAN_fit = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit = {k: v for k, v in pms_HDBSCAN_fit.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit = bridgeHDBSCAN[${this.id}].fit(**pms_HDBSCAN_fit)`;
    return this._py`res_HDBSCAN_fit.tolist() if hasattr(res_HDBSCAN_fit, 'tolist') else res_HDBSCAN_fit`;
  }
  /**
    Cluster X and return the associated cluster labels.
   */
  async fit_predict(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before fit_predict()");
    }
    await this._py.ex`pms_HDBSCAN_fit_predict = {'X': np.array(${opts["X"] ?? void 0}) if ${opts["X"] !== void 0} else None, 'y': ${opts["y"] ?? void 0}}

pms_HDBSCAN_fit_predict = {k: v for k, v in pms_HDBSCAN_fit_predict.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_fit_predict = bridgeHDBSCAN[${this.id}].fit_predict(**pms_HDBSCAN_fit_predict)`;
    return this._py`res_HDBSCAN_fit_predict.tolist() if hasattr(res_HDBSCAN_fit_predict, 'tolist') else res_HDBSCAN_fit_predict`;
  }
  /**
      Get metadata routing of this object.
  
      Please check [User Guide](../../metadata_routing.html#metadata-routing) on how the routing mechanism works.
     */
  async get_metadata_routing(opts) {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before get_metadata_routing()");
    }
    await this._py.ex`pms_HDBSCAN_get_metadata_routing = {'routing': ${opts["routing"] ?? void 0}}

pms_HDBSCAN_get_metadata_routing = {k: v for k, v in pms_HDBSCAN_get_metadata_routing.items() if v is not None}`;
    await this._py.ex`res_HDBSCAN_get_metadata_routing = bridgeHDBSCAN[${this.id}].get_metadata_routing(**pms_HDBSCAN_get_metadata_routing)`;
    return this._py`res_HDBSCAN_get_metadata_routing.tolist() if hasattr(res_HDBSCAN_get_metadata_routing, 'tolist') else res_HDBSCAN_get_metadata_routing`;
  }
  /**
    Cluster labels for each point in the dataset given to [fit](../../glossary.html#term-fit). Outliers are labeled as follows:
   */
  get labels_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing labels_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_labels_ = bridgeHDBSCAN[${this.id}].labels_`;
      return this._py`attr_HDBSCAN_labels_.tolist() if hasattr(attr_HDBSCAN_labels_, 'tolist') else attr_HDBSCAN_labels_`;
    })();
  }
  /**
    The strength with which each sample is a member of its assigned cluster.
   */
  get probabilities_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing probabilities_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_probabilities_ = bridgeHDBSCAN[${this.id}].probabilities_`;
      return this._py`attr_HDBSCAN_probabilities_.tolist() if hasattr(attr_HDBSCAN_probabilities_, 'tolist') else attr_HDBSCAN_probabilities_`;
    })();
  }
  /**
    Number of features seen during [fit](../../glossary.html#term-fit).
   */
  get n_features_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing n_features_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_n_features_in_ = bridgeHDBSCAN[${this.id}].n_features_in_`;
      return this._py`attr_HDBSCAN_n_features_in_.tolist() if hasattr(attr_HDBSCAN_n_features_in_, 'tolist') else attr_HDBSCAN_n_features_in_`;
    })();
  }
  /**
    Names of features seen during [fit](../../glossary.html#term-fit). Defined only when `X` has feature names that are all strings.
   */
  get feature_names_in_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error(
        "HDBSCAN must call init() before accessing feature_names_in_"
      );
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_feature_names_in_ = bridgeHDBSCAN[${this.id}].feature_names_in_`;
      return this._py`attr_HDBSCAN_feature_names_in_.tolist() if hasattr(attr_HDBSCAN_feature_names_in_, 'tolist') else attr_HDBSCAN_feature_names_in_`;
    })();
  }
  /**
      A collection containing the centroid of each cluster calculated under the standard euclidean metric. The centroids may fall “outside” their respective clusters if the clusters themselves are non-convex.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get centroids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing centroids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_centroids_ = bridgeHDBSCAN[${this.id}].centroids_`;
      return this._py`attr_HDBSCAN_centroids_.tolist() if hasattr(attr_HDBSCAN_centroids_, 'tolist') else attr_HDBSCAN_centroids_`;
    })();
  }
  /**
      A collection containing the medoid of each cluster calculated under the whichever metric was passed to the `metric` parameter. The medoids are points in the original cluster which minimize the average distance to all other points in that cluster under the chosen metric. These can be thought of as the result of projecting the `metric`\-based centroid back onto the cluster.
  
      Note that `n\_clusters` only counts non-outlier clusters. That is to say, the `\-1, \-2, \-3` labels for the outlier clusters are excluded.
     */
  get medoids_() {
    if (this._isDisposed) {
      throw new Error("This HDBSCAN instance has already been disposed");
    }
    if (!this._isInitialized) {
      throw new Error("HDBSCAN must call init() before accessing medoids_");
    }
    return (async () => {
      await this._py.ex`attr_HDBSCAN_medoids_ = bridgeHDBSCAN[${this.id}].medoids_`;
      return this._py`attr_HDBSCAN_medoids_.tolist() if hasattr(attr_HDBSCAN_medoids_, 'tolist') else attr_HDBSCAN_medoids_`;
    })();
  }
};
export {
  HDBSCAN
};
//# sourceMappingURL=HDBSCAN.js.map